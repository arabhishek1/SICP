Ex 1.1

	1.(+ 5 3 4)
	    9

	2. (- 9 1)
	    8

	3.(/ 6 2)
		3

	4.(+ (* 2 4) (- 4 6)) 
		6

	5.	(define a 3)
		(define b (+ a 1))
		(+ a b (* a b))
		19

	6.(= a b)
		4


	7. (if (and (> b a) (< b (* a b)))
		b
		a)
		4

	8.(cond ((= a 4) 6)
			((= b 4) (+ 6 7 a))
			(else 25))
		6

	9.(+ 2 (if (> b a) b a))
		6

	10.(* (cond ((> a b) a)
				((< a b) b)
				(else -1))
		(+ a 1))
		-5

Ex 1.2
	5+4+(2-(3-(6+4/5))) / 3(6-2)(2-7)
		(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

Ex 1.3
	Define a procedure that takes three numbers as arguments and returns the sum of the
	squares of the two larger numbers.

	(define (square no) (* no no) )
	(define (sum_of_squares no_1 no_2 no_ 3) (+ (square no_1) (square no_2) (square no_3) ) )
	(define (min_of_two no_1 no_2) (if (< no_1 no_2) no_1 no_2)) 
	(define (min_of_three no_1 no_2 no_3) ( min_of_two( min_of_two(no_1 no_2) no_3)))
	(define (sum_of_larger_two_no no_1 no_2 no_3) (- sum_of_squares(no_1 no_2 no_3) square(min_of_three(x y z) ) ) )

Ex 1.4
	(define (a-plus-abs-b a b)
		((if (> b 0) + -) a b))

		Computes sum of first no and absolute value of second no

Ex 1.5
	
	(define (p) (p))
	(define (test x y)
	(if (= x 0)
		0
		y))
Then he evaluates the expression
(test 0 (p))

	applicative order:
		Here arguments will be evaluated first ,then it applies procedure on its arguments .Hence p will be called

	Normal order:
		Here arguments will not be evaluated until it is required ,hence test will be called which will return 0 ,hence p will remain uncalled.



